diff --git a/node_modules/@remix-run/server-runtime/browser/index.js b/node_modules/@remix-run/server-runtime/browser/index.js
new file mode 100644
index 0000000..6d2316f
--- /dev/null
+++ b/node_modules/@remix-run/server-runtime/browser/index.js
@@ -0,0 +1,1099 @@
+/**
+ * @remix-run/server-runtime v1.0.6
+ *
+ * Copyright (c) Remix Software Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE.md file in the root directory of this source tree.
+ *
+ * @license MIT
+ */
+import { parse, serialize } from 'cookie';
+import { splitCookiesString } from 'set-cookie-parser';
+import { matchRoutes } from 'react-router-dom';
+import jsesc from 'jsesc';
+
+/**
+ * Creates and returns a new Cookie.
+ */
+function createCookie(name, {
+  secrets = [],
+  ...options
+} = {}) {
+  return {
+    get name() {
+      return name;
+    },
+
+    get isSigned() {
+      return secrets.length > 0;
+    },
+
+    get expires() {
+      // Max-Age takes precedence over Expires
+      return typeof options.maxAge !== "undefined" ? new Date(Date.now() + options.maxAge * 1000) : options.expires;
+    },
+
+    async parse(cookieHeader, parseOptions) {
+      if (!cookieHeader) return null;
+      let cookies = parse(cookieHeader, { ...options,
+        ...parseOptions
+      });
+      return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(cookies[name], secrets) : null;
+    },
+
+    async serialize(value, serializeOptions) {
+      return serialize(name, value === "" ? "" : await encodeCookieValue(value, secrets), { ...options,
+        ...serializeOptions
+      });
+    }
+
+  };
+}
+function isCookie(object) {
+  return object != null && typeof object.name === "string" && typeof object.isSigned === "boolean" && typeof object.parse === "function" && typeof object.serialize === "function";
+}
+
+async function encodeCookieValue(value, secrets) {
+  let encoded = encodeData(value);
+
+  if (secrets.length > 0) {
+    encoded = await sign(encoded, secrets[0]);
+  }
+
+  return encoded;
+}
+
+async function decodeCookieValue(value, secrets) {
+  if (secrets.length > 0) {
+    for (let secret of secrets) {
+      let unsignedValue = await unsign(value, secret);
+
+      if (unsignedValue !== false) {
+        return decodeData(unsignedValue);
+      }
+    }
+
+    return null;
+  }
+
+  return decodeData(value);
+}
+
+function encodeData(value) {
+  return btoa(JSON.stringify(value));
+}
+
+function decodeData(value) {
+  try {
+    return JSON.parse(atob(value));
+  } catch (error) {
+    return {};
+  }
+}
+
+/**
+ * A JSON response. Converts `data` to JSON and sets the `Content-Type` header.
+ */
+function json(data, init = {}) {
+  let responseInit = init;
+
+  if (typeof init === "number") {
+    responseInit = {
+      status: init
+    };
+  }
+
+  let headers = new Headers(responseInit.headers);
+
+  if (!headers.has("Content-Type")) {
+    headers.set("Content-Type", "application/json; charset=utf-8");
+  }
+
+  return new Response(JSON.stringify(data), { ...responseInit,
+    headers
+  });
+}
+/**
+ * A redirect response. Sets the status code and the `Location` header.
+ * Defaults to "302 Found".
+ */
+
+function redirect(url, init = 302) {
+  let responseInit = init;
+
+  if (typeof init === "number") {
+    responseInit = {
+      status: init
+    };
+  } else if (typeof responseInit.status === "undefined") {
+    responseInit.status = 302;
+  }
+
+  let headers = new Headers(responseInit.headers);
+  headers.set("Location", url);
+  return new Response(null, { ...responseInit,
+    headers
+  });
+}
+
+/**
+ * An object of arbitrary for route loaders and actions provided by the
+ * server's `getLoadContext()` function.
+ */
+
+async function loadRouteData(build, routeId, request, context, params) {
+  let routeModule = build.routes[routeId].module;
+
+  if (!routeModule.loader) {
+    return Promise.resolve(json(null));
+  }
+
+  let result;
+
+  try {
+    result = await routeModule.loader({
+      request,
+      context,
+      params
+    });
+  } catch (error) {
+    if (!isResponse(error)) {
+      throw error;
+    }
+
+    if (!isRedirectResponse(error)) {
+      error.headers.set("X-Remix-Catch", "yes");
+    }
+
+    result = error;
+  }
+
+  if (result === undefined) {
+    throw new Error(`You defined a loader for route "${routeId}" but didn't return ` + `anything from your \`loader\` function. Please return a value or \`null\`.`);
+  }
+
+  return isResponse(result) ? result : json(result);
+}
+async function callRouteAction(build, routeId, request, context, params) {
+  let routeModule = build.routes[routeId].module;
+
+  if (!routeModule.action) {
+    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide ` + `an \`action\` for route "${routeId}", so there is no way to handle the ` + `request.`);
+  }
+
+  let result;
+
+  try {
+    result = await routeModule.action({
+      request,
+      context,
+      params
+    });
+  } catch (error) {
+    if (!isResponse(error)) {
+      throw error;
+    }
+
+    if (!isRedirectResponse(error)) {
+      error.headers.set("X-Remix-Catch", "yes");
+    }
+
+    result = error;
+  }
+
+  if (result === undefined) {
+    throw new Error(`You defined an action for route "${routeId}" but didn't return ` + `anything from your \`action\` function. Please return a value or \`null\`.`);
+  }
+
+  return isResponse(result) ? result : json(result);
+}
+function isCatchResponse(value) {
+  return isResponse(value) && value.headers.get("X-Remix-Catch") != null;
+}
+
+function isResponse(value) {
+  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
+}
+
+const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
+function isRedirectResponse(response) {
+  return redirectStatusCodes.has(response.status);
+}
+function extractData(response) {
+  let contentType = response.headers.get("Content-Type");
+
+  if (contentType && /\bapplication\/json\b/.test(contentType)) {
+    return response.json();
+  } // What other data types do we need to handle here? What other kinds of
+  // responses are people going to be returning from their loaders?
+  // - application/x-www-form-urlencoded ?
+  // - multipart/form-data ?
+  // - binary (audio/video) ?
+
+
+  return response.text();
+}
+
+function createEntryMatches(matches, routes) {
+  return matches.map(match => ({
+    params: match.params,
+    pathname: match.pathname,
+    route: routes[match.route.id]
+  }));
+}
+function createEntryRouteModules(manifest) {
+  return Object.keys(manifest).reduce((memo, routeId) => {
+    memo[routeId] = manifest[routeId].module;
+    return memo;
+  }, {});
+}
+
+/**
+ * This thing probably warrants some explanation.
+ *
+ * The whole point here is to emulate componentDidCatch for server rendering and
+ * data loading. It can get tricky. React can do this on component boundaries
+ * but doesn't support it for server rendering or data loading. We know enough
+ * with nested routes to be able to emulate the behavior (because we know them
+ * statically before rendering.)
+ *
+ * Each route can export an `ErrorBoundary`.
+ *
+ * - When rendering throws an error, the nearest error boundary will render
+ *   (normal react componentDidCatch). This will be the route's own boundary, but
+ *   if none is provided, it will bubble up to the parents.
+ * - When data loading throws an error, the nearest error boundary will render
+ * - When performing an action, the nearest error boundary for the action's
+ *   route tree will render (no redirect happens)
+ *
+ * During normal react rendering, we do nothing special, just normal
+ * componentDidCatch.
+ *
+ * For server rendering, we mutate `renderBoundaryRouteId` to know the last
+ * layout that has an error boundary that tried to render. This emulates which
+ * layout would catch a thrown error. If the rendering fails, we catch the error
+ * on the server, and go again a second time with the emulator holding on to the
+ * information it needs to render the same error boundary as a dynamically
+ * thrown render error.
+ *
+ * When data loading, server or client side, we use the emulator to likewise
+ * hang on to the error and re-render at the appropriate layout (where a thrown
+ * error would have been caught by cDC).
+ *
+ * When actions throw, it all works the same. There's an edge case to be aware
+ * of though. Actions normally are required to redirect, but in the case of
+ * errors, we render the action's route with the emulator holding on to the
+ * error. If during this render a parent route/loader throws we ignore that new
+ * error and render the action's original error as deeply as possible. In other
+ * words, we simply ignore the new error and use the action's error in place
+ * because it came first, and that just wouldn't be fair to let errors cut in
+ * line.
+ */
+async function serializeError(error) {
+  return {
+    message: error.message,
+    stack: error.stack
+  };
+}
+
+function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
+  return matches.reduce((parentHeaders, match, index) => {
+    let routeModule = build.routes[match.route.id].module;
+    let loaderHeaders = routeLoaderResponses[index] ? routeLoaderResponses[index].headers : new Headers();
+    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
+    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
+      loaderHeaders,
+      parentHeaders,
+      actionHeaders
+    }) : routeModule.headers : undefined); // Automatically preserve Set-Cookie headers that were set either by the
+    // loader or by a parent route.
+
+    prependCookies(actionHeaders, headers);
+    prependCookies(loaderHeaders, headers);
+    prependCookies(parentHeaders, headers);
+    return headers;
+  }, new Headers());
+}
+
+function prependCookies(parentHeaders, childHeaders) {
+  let parentSetCookieString = parentHeaders.get("Set-Cookie");
+
+  if (parentSetCookieString) {
+    let cookies = splitCookiesString(parentSetCookieString);
+    cookies.forEach(cookie => {
+      childHeaders.append("Set-Cookie", cookie);
+    });
+  }
+}
+
+// TODO: export/import from react-router-dom
+function matchServerRoutes(routes, pathname) {
+  let matches = matchRoutes(routes, pathname);
+  if (!matches) return null;
+  return matches.map(match => ({
+    params: match.params,
+    pathname: match.pathname,
+    route: match.route
+  }));
+}
+
+/**
+ * The mode to use when running the server.
+ */
+let ServerMode;
+
+(function (ServerMode) {
+  ServerMode["Development"] = "development";
+  ServerMode["Production"] = "production";
+  ServerMode["Test"] = "test";
+})(ServerMode || (ServerMode = {}));
+
+function isServerMode(value) {
+  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
+}
+
+// NOTE: make sure to change the Route in remix-react if you change this
+// NOTE: make sure to change the EntryRoute in remix-react if you change this
+function createRoutes(manifest, parentId) {
+  return Object.keys(manifest).filter(key => manifest[key].parentId === parentId).map(id => ({ ...manifest[id],
+    children: createRoutes(manifest, id)
+  }));
+}
+
+async function createRouteData(matches, responses) {
+  let data = await Promise.all(responses.map(extractData));
+  return matches.reduce((memo, match, index) => {
+    memo[match.route.id] = data[index];
+    return memo;
+  }, {});
+}
+async function createActionData(response) {
+  return extractData(response);
+}
+
+function createServerHandoffString(serverHandoff) {
+  // Use jsesc to escape data returned from the loaders. This string is
+  // inserted directly into the HTML in the `<Scripts>` element.
+  return jsesc(serverHandoff, {
+    isScriptContext: true
+  });
+}
+
+/**
+ * The main request handler for a Remix server. This handler runs in the context
+ * of a cloud provider's server (e.g. Express on Firebase) or locally via their
+ * dev tools.
+ */
+
+function getRequestType(request, matches) {
+  if (isDataRequest(request)) {
+    return "data";
+  }
+
+  if (!matches) {
+    return "document";
+  }
+
+  let match = matches.slice(-1)[0];
+
+  if (!match.route.module.default) {
+    return "resource";
+  }
+
+  return "document";
+}
+/**
+ * Creates a function that serves HTTP requests.
+ */
+
+
+function createRequestHandler(build, platform, mode) {
+  let routes = createRoutes(build.routes);
+  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;
+  return async (request, loadContext = {}) => {
+    let url = new URL(request.url);
+    let matches = matchServerRoutes(routes, url.pathname);
+    let requestType = getRequestType(request, matches);
+    let response;
+
+    switch (requestType) {
+      // has _data
+      case "data":
+        response = await handleDataRequest(request, loadContext, build, platform, matches);
+        break;
+      // no _data & default export
+
+      case "document":
+        response = await handleDocumentRequest(request, loadContext, build, platform, routes, serverMode);
+        break;
+      // no _data  or default export
+
+      case "resource":
+        response = await handleResourceRequest(request, loadContext, build, platform, matches);
+        break;
+    }
+
+    if (isHeadRequest(request)) {
+      return new Response(null, {
+        headers: response.headers,
+        status: response.status,
+        statusText: response.statusText
+      });
+    }
+
+    return response;
+  };
+}
+
+async function handleResourceRequest(request, loadContext, build, platform, matches) {
+  let url = new URL(request.url);
+
+  if (!matches) {
+    return jsonError(`No route matches URL "${url.pathname}"`, 404);
+  }
+
+  let routeMatch = matches.slice(-1)[0];
+
+  try {
+    return isActionRequest(request) ? await callRouteAction(build, routeMatch.route.id, request, loadContext, routeMatch.params) : await loadRouteData(build, routeMatch.route.id, request, loadContext, routeMatch.params);
+  } catch (error) {
+    var _platform$formatServe;
+
+    let formattedError = (await ((_platform$formatServe = platform.formatServerError) === null || _platform$formatServe === void 0 ? void 0 : _platform$formatServe.call(platform, error))) || error;
+    throw formattedError;
+  }
+}
+
+async function handleDataRequest(request, loadContext, build, platform, matches) {
+  if (!isValidRequestMethod(request)) {
+    return jsonError(`Invalid request method "${request.method}"`, 405);
+  }
+
+  let url = new URL(request.url);
+
+  if (!matches) {
+    return jsonError(`No route matches URL "${url.pathname}"`, 404);
+  }
+
+  let routeMatch;
+
+  if (isActionRequest(request)) {
+    routeMatch = matches[matches.length - 1];
+
+    if (!isIndexRequestUrl(url) && matches[matches.length - 1].route.id.endsWith("/index")) {
+      routeMatch = matches[matches.length - 2];
+    }
+  } else {
+    let routeId = url.searchParams.get("_data");
+
+    if (!routeId) {
+      return jsonError(`Missing route id in ?_data`, 403);
+    }
+
+    let match = matches.find(match => match.route.id === routeId);
+
+    if (!match) {
+      return jsonError(`Route "${routeId}" does not match URL "${url.pathname}"`, 403);
+    }
+
+    routeMatch = match;
+  }
+
+  let response;
+
+  try {
+    response = isActionRequest(request) ? await callRouteAction(build, routeMatch.route.id, stripIndexParam(stripDataParam(request.clone())), loadContext, routeMatch.params) : await loadRouteData(build, routeMatch.route.id, stripIndexParam(stripDataParam(request.clone())), loadContext, routeMatch.params);
+  } catch (error) {
+    var _platform$formatServe2;
+
+    let formattedError = (await ((_platform$formatServe2 = platform.formatServerError) === null || _platform$formatServe2 === void 0 ? void 0 : _platform$formatServe2.call(platform, error))) || error;
+    response = json(await serializeError(formattedError), {
+      status: 500,
+      headers: {
+        "X-Remix-Error": "unfortunately, yes"
+      }
+    });
+  }
+
+  if (isRedirectResponse(response)) {
+    // We don't have any way to prevent a fetch request from following
+    // redirects. So we use the `X-Remix-Redirect` header to indicate the
+    // next URL, and then "follow" the redirect manually on the client.
+    let headers = new Headers(response.headers);
+    headers.set("X-Remix-Redirect", headers.get("Location"));
+    headers.delete("Location");
+    return new Response(null, {
+      status: 204,
+      headers
+    });
+  }
+
+  if (build.entry.module.handleDataRequest) {
+    return build.entry.module.handleDataRequest(response, {
+      request: request.clone(),
+      context: loadContext,
+      params: routeMatch.params
+    });
+  }
+
+  return response;
+}
+
+async function handleDocumentRequest(request, loadContext, build, platform, routes, serverMode) {
+  let url = new URL(request.url);
+  let requestState = isValidRequestMethod(request) ? "ok" : "invalid-request";
+  let matches = requestState === "ok" ? matchServerRoutes(routes, url.pathname) : null;
+
+  if (!matches) {
+    // If we do not match a user-provided-route, fall back to the root
+    // to allow the CatchBoundary to take over while maintining invalid
+    // request state if already set
+    if (requestState === "ok") {
+      requestState = "no-match";
+    }
+
+    matches = [{
+      params: {},
+      pathname: "",
+      route: routes[0]
+    }];
+  }
+
+  let componentDidCatchEmulator = {
+    trackBoundaries: true,
+    trackCatchBoundaries: true,
+    catchBoundaryRouteId: null,
+    renderBoundaryRouteId: null,
+    loaderBoundaryRouteId: null,
+    error: undefined,
+    catch: undefined
+  };
+  let responseState = "ok";
+  let actionResponse;
+  let actionRouteId;
+
+  if (requestState !== "ok") {
+    responseState = "caught";
+    componentDidCatchEmulator.trackCatchBoundaries = false;
+    let withBoundaries = getMatchesUpToDeepestBoundary(matches, "CatchBoundary");
+    componentDidCatchEmulator.catchBoundaryRouteId = withBoundaries.length > 0 ? withBoundaries[withBoundaries.length - 1].route.id : null;
+    componentDidCatchEmulator.catch = {
+      status: requestState === "no-match" ? 404 : 405,
+      statusText: requestState === "no-match" ? "Not Found" : "Method Not Allowed",
+      data: null
+    };
+  } else if (isActionRequest(request)) {
+    let actionMatch = matches[matches.length - 1];
+
+    if (!isIndexRequestUrl(url) && actionMatch.route.id.endsWith("/index")) {
+      actionMatch = matches[matches.length - 2];
+    }
+
+    actionRouteId = actionMatch.route.id;
+
+    try {
+      actionResponse = await callRouteAction(build, actionMatch.route.id, stripIndexParam(stripDataParam(request.clone())), loadContext, actionMatch.params);
+
+      if (isRedirectResponse(actionResponse)) {
+        return actionResponse;
+      }
+    } catch (error) {
+      var _platform$formatServe3;
+
+      let formattedError = (await ((_platform$formatServe3 = platform.formatServerError) === null || _platform$formatServe3 === void 0 ? void 0 : _platform$formatServe3.call(platform, error))) || error;
+      responseState = "error";
+      let withBoundaries = getMatchesUpToDeepestBoundary(matches, "ErrorBoundary");
+      componentDidCatchEmulator.loaderBoundaryRouteId = withBoundaries[withBoundaries.length - 1].route.id;
+      componentDidCatchEmulator.error = await serializeError(formattedError);
+    }
+  }
+
+  if (actionResponse && isCatchResponse(actionResponse)) {
+    responseState = "caught";
+    let withBoundaries = getMatchesUpToDeepestBoundary(matches, "CatchBoundary");
+    componentDidCatchEmulator.trackCatchBoundaries = false;
+    componentDidCatchEmulator.catchBoundaryRouteId = withBoundaries[withBoundaries.length - 1].route.id;
+    componentDidCatchEmulator.catch = {
+      status: actionResponse.status,
+      statusText: actionResponse.statusText,
+      data: await extractData(actionResponse.clone())
+    };
+  } // If we did not match a route, there is no need to call any loaders
+
+
+  let matchesToLoad = requestState !== "ok" ? [] : matches;
+
+  switch (responseState) {
+    case "caught":
+      matchesToLoad = getMatchesUpToDeepestBoundary( // get rid of the action, we don't want to call it's loader either
+      // because we'll be rendering the catch boundary, if you can get access
+      // to the loader data in the catch boundary then how the heck is it
+      // supposed to deal with thrown responses?
+      matches.slice(0, -1), "CatchBoundary");
+      break;
+
+    case "error":
+      matchesToLoad = getMatchesUpToDeepestBoundary( // get rid of the action, we don't want to call it's loader either
+      // because we'll be rendering the error boundary, if you can get access
+      // to the loader data in the error boundary then how the heck is it
+      // supposed to deal with errors in the loader, too?
+      matches.slice(0, -1), "ErrorBoundary");
+      break;
+  } // Run all data loaders in parallel. Await them in series below.  Note: This
+  // code is a little weird due to the way unhandled promise rejections are
+  // handled in node. We use a .catch() handler on each promise to avoid the
+  // warning, then handle errors manually afterwards.
+
+
+  let routeLoaderPromises = matchesToLoad.map(match => loadRouteData(build, match.route.id, stripIndexParam(stripDataParam(request.clone())), loadContext, match.params).catch(error => error));
+  let routeLoaderResults = await Promise.all(routeLoaderPromises);
+
+  for (let [index, response] of routeLoaderResults.entries()) {
+    let route = matches[index].route;
+    let routeModule = build.routes[route.id].module; // Rare case where an action throws an error, and then when we try to render
+    // the action's page to tell the user about the the error, a loader above
+    // the action route *also* threw an error or tried to redirect!
+    //
+    // Instead of rendering the loader error or redirecting like usual, we
+    // ignore the loader error or redirect because the action error was first
+    // and is higher priority to surface.  Perhaps the action error is the
+    // reason the loader blows up now! It happened first and is more important
+    // to address.
+    //
+    // We just give up and move on with rendering the error as deeply as we can,
+    // which is the previous iteration of this loop
+
+    if (responseState === "error" && (response instanceof Error || isRedirectResponse(response)) || responseState === "caught" && isCatchResponse(response)) {
+      break;
+    }
+
+    if (componentDidCatchEmulator.catch || componentDidCatchEmulator.error) {
+      continue;
+    }
+
+    if (routeModule.CatchBoundary) {
+      componentDidCatchEmulator.catchBoundaryRouteId = route.id;
+    }
+
+    if (routeModule.ErrorBoundary) {
+      componentDidCatchEmulator.loaderBoundaryRouteId = route.id;
+    }
+
+    if (response instanceof Error) {
+      var _platform$formatServe4;
+
+      if (serverMode !== ServerMode.Test) {
+        console.error(`There was an error running the data loader for route ${route.id}`);
+      }
+
+      let formattedError = (await ((_platform$formatServe4 = platform.formatServerError) === null || _platform$formatServe4 === void 0 ? void 0 : _platform$formatServe4.call(platform, response))) || response;
+      componentDidCatchEmulator.error = await serializeError(formattedError);
+      routeLoaderResults[index] = json(null, {
+        status: 500
+      });
+    } else if (isRedirectResponse(response)) {
+      return response;
+    } else if (isCatchResponse(response)) {
+      componentDidCatchEmulator.trackCatchBoundaries = false;
+      componentDidCatchEmulator.catch = {
+        status: response.status,
+        statusText: response.statusText,
+        data: await extractData(response.clone())
+      };
+      routeLoaderResults[index] = json(null, {
+        status: response.status
+      });
+    }
+  } // We already filtered out all Errors, so these are all Responses.
+
+
+  let routeLoaderResponses = routeLoaderResults; // Handle responses with a non-200 status code. The first loader with a
+  // non-200 status code determines the status code for the whole response.
+
+  let notOkResponse = [actionResponse, ...routeLoaderResponses].find(response => response && response.status !== 200);
+  let statusCode = requestState === "no-match" ? 404 : requestState === "invalid-request" ? 405 : responseState === "error" ? 500 : notOkResponse ? notOkResponse.status : 200;
+  let renderableMatches = getRenderableMatches(matches, componentDidCatchEmulator);
+  let serverEntryModule = build.entry.module;
+  let headers = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
+  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);
+  let routeData = await createRouteData(renderableMatches, routeLoaderResponses);
+  let actionData = actionResponse && actionRouteId ? {
+    [actionRouteId]: await createActionData(actionResponse.clone())
+  } : undefined;
+  let routeModules = createEntryRouteModules(build.routes);
+  let serverHandoff = {
+    matches: entryMatches,
+    componentDidCatchEmulator,
+    routeData,
+    actionData
+  };
+  let entryContext = { ...serverHandoff,
+    manifest: build.assets,
+    routeModules,
+    serverHandoffString: createServerHandoffString(serverHandoff)
+  };
+  let response;
+
+  try {
+    response = await serverEntryModule.default(request, statusCode, headers, entryContext);
+  } catch (error) {
+    var _platform$formatServe5;
+
+    let formattedError = (await ((_platform$formatServe5 = platform.formatServerError) === null || _platform$formatServe5 === void 0 ? void 0 : _platform$formatServe5.call(platform, error))) || error;
+
+    if (serverMode !== ServerMode.Test) {
+      console.error(formattedError);
+    }
+
+    statusCode = 500; // Go again, this time with the componentDidCatch emulation. As it rendered
+    // last time we mutated `componentDidCatch.routeId` for the last rendered
+    // route, now we know where to render the error boundary (feels a little
+    // hacky but that's how hooks work). This tells the emulator to stop
+    // tracking the `routeId` as we render because we already have an error to
+    // render.
+
+    componentDidCatchEmulator.trackBoundaries = false;
+    componentDidCatchEmulator.error = await serializeError(formattedError);
+    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
+
+    try {
+      response = await serverEntryModule.default(request, statusCode, headers, entryContext);
+    } catch (error) {
+      var _platform$formatServe6;
+
+      let formattedError = (await ((_platform$formatServe6 = platform.formatServerError) === null || _platform$formatServe6 === void 0 ? void 0 : _platform$formatServe6.call(platform, error))) || error;
+
+      if (serverMode !== ServerMode.Test) {
+        console.error(formattedError);
+      } // Good grief folks, get your act together ðŸ˜‚!
+
+
+      response = new Response(`Unexpected Server Error\n\n${formattedError.message}`, {
+        status: 500,
+        headers: {
+          "Content-Type": "text/plain"
+        }
+      });
+    }
+  }
+
+  return response;
+}
+
+function jsonError(error, status = 403) {
+  return json({
+    error
+  }, {
+    status
+  });
+}
+
+function isActionRequest(request) {
+  let method = request.method.toLowerCase();
+  return method === "post" || method === "put" || method === "patch" || method === "delete";
+}
+
+function isValidRequestMethod(request) {
+  return request.method.toLowerCase() === "get" || isHeadRequest(request) || isActionRequest(request);
+}
+
+function isHeadRequest(request) {
+  return request.method.toLowerCase() === "head";
+}
+
+function isDataRequest(request) {
+  return new URL(request.url).searchParams.has("_data");
+}
+
+function isIndexRequestUrl(url) {
+  let indexRequest = false;
+
+  for (let param of url.searchParams.getAll("index")) {
+    if (!param) {
+      indexRequest = true;
+    }
+  }
+
+  return indexRequest;
+}
+
+function stripIndexParam(request) {
+  let url = new URL(request.url);
+  let indexValues = url.searchParams.getAll("index");
+  url.searchParams.delete("index");
+  let indexValuesToKeep = [];
+
+  for (let indexValue of indexValues) {
+    if (indexValue) {
+      indexValuesToKeep.push(indexValue);
+    }
+  }
+
+  for (let toKeep of indexValuesToKeep) {
+    url.searchParams.append("index", toKeep);
+  }
+
+  return new Request(url.toString(), request);
+}
+
+function stripDataParam(request) {
+  let url = new URL(request.url);
+  url.searchParams.delete("_data");
+  return new Request(url.toString(), request);
+} // TODO: update to use key for lookup
+
+
+function getMatchesUpToDeepestBoundary(matches, key) {
+  let deepestBoundaryIndex = -1;
+  matches.forEach((match, index) => {
+    if (match.route.module[key]) {
+      deepestBoundaryIndex = index;
+    }
+  });
+
+  if (deepestBoundaryIndex === -1) {
+    // no route error boundaries, don't need to call any loaders
+    return [];
+  }
+
+  return matches.slice(0, deepestBoundaryIndex + 1);
+} // This prevents `<Outlet/>` from rendering anything below where the error threw
+// TODO: maybe do this in <RemixErrorBoundary + context>
+
+
+function getRenderableMatches(matches, componentDidCatchEmulator) {
+  // no error, no worries
+  if (!componentDidCatchEmulator.catch && !componentDidCatchEmulator.error) {
+    return matches;
+  }
+
+  let lastRenderableIndex = -1;
+  matches.forEach((match, index) => {
+    let id = match.route.id;
+
+    if (componentDidCatchEmulator.renderBoundaryRouteId === id || componentDidCatchEmulator.loaderBoundaryRouteId === id || componentDidCatchEmulator.catchBoundaryRouteId === id) {
+      lastRenderableIndex = index;
+    }
+  });
+  return matches.slice(0, lastRenderableIndex + 1);
+}
+
+const alreadyWarned = {};
+function warnOnce(condition, message) {
+  if (!condition && !alreadyWarned[message]) {
+    alreadyWarned[message] = true;
+    console.warn(message);
+  }
+}
+
+/**
+ * An object of name/value pairs to be used in the session.
+ */
+
+function flash(name) {
+  return `__flash_${name}__`;
+}
+/**
+ * Creates a new Session object.
+ *
+ * Note: This function is typically not invoked directly by application code.
+ * Instead, use a `SessionStorage` object's `getSession` method.
+ */
+
+
+function createSession(initialData = {}, id = "") {
+  let map = new Map(Object.entries(initialData));
+  return {
+    get id() {
+      return id;
+    },
+
+    get data() {
+      return Object.fromEntries(map);
+    },
+
+    has(name) {
+      return map.has(name) || map.has(flash(name));
+    },
+
+    get(name) {
+      if (map.has(name)) return map.get(name);
+      let flashName = flash(name);
+
+      if (map.has(flashName)) {
+        let value = map.get(flashName);
+        map.delete(flashName);
+        return value;
+      }
+
+      return undefined;
+    },
+
+    set(name, value) {
+      map.set(name, value);
+    },
+
+    flash(name, value) {
+      map.set(flash(name), value);
+    },
+
+    unset(name) {
+      map.delete(name);
+    }
+
+  };
+}
+function isSession(object) {
+  return object != null && typeof object.id === "string" && typeof object.data !== "undefined" && typeof object.has === "function" && typeof object.get === "function" && typeof object.set === "function" && typeof object.flash === "function" && typeof object.unset === "function";
+}
+/**
+ * SessionStorage stores session data between HTTP requests and knows how to
+ * parse and create cookies.
+ *
+ * A SessionStorage creates Session objects using a `Cookie` header as input.
+ * Then, later it generates the `Set-Cookie` header to be used in the response.
+ */
+
+/**
+ * Creates a SessionStorage object using a SessionIdStorageStrategy.
+ *
+ * Note: This is a low-level API that should only be used if none of the
+ * existing session storage options meet your requirements.
+ */
+function createSessionStorage({
+  cookie: cookieArg,
+  createData,
+  readData,
+  updateData,
+  deleteData
+}) {
+  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg && cookieArg.name || "__session", cookieArg);
+  warnOnceAboutSigningSessionCookie(cookie);
+  return {
+    async getSession(cookieHeader, options) {
+      let id = cookieHeader && (await cookie.parse(cookieHeader, options));
+      let data = id && (await readData(id));
+      return createSession(data || {}, id || "");
+    },
+
+    async commitSession(session, options) {
+      let {
+        id,
+        data
+      } = session;
+
+      if (id) {
+        await updateData(id, data, cookie.expires);
+      } else {
+        id = await createData(data, cookie.expires);
+      }
+
+      return cookie.serialize(id, options);
+    },
+
+    async destroySession(session, options) {
+      await deleteData(session.id);
+      return cookie.serialize("", { ...options,
+        expires: new Date(0)
+      });
+    }
+
+  };
+}
+function warnOnceAboutSigningSessionCookie(cookie) {
+  warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be ` + `signed to prevent tampering on the client before they are sent back to the ` + `server.`
+  /* TODO: Update link with new docs. See https://remix.run/cookies#signing-cookies ` +
+  `for more information.` */
+  );
+}
+
+/**
+ * Creates and returns a SessionStorage object that stores all session data
+ * directly in the session cookie itself.
+ *
+ * This has the advantage that no database or other backend services are
+ * needed, and can help to simplify some load-balanced scenarios. However, it
+ * also has the limitation that serialized session data may not exceed the
+ * browser's maximum cookie size. Trade-offs!
+ */
+function createCookieSessionStorage({
+  cookie: cookieArg
+} = {}) {
+  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg && cookieArg.name || "__session", cookieArg);
+  warnOnceAboutSigningSessionCookie(cookie);
+  return {
+    async getSession(cookieHeader, options) {
+      return createSession(cookieHeader && (await cookie.parse(cookieHeader, options)) || {});
+    },
+
+    async commitSession(session, options) {
+      return cookie.serialize(session.data, options);
+    },
+
+    async destroySession(_session, options) {
+      return cookie.serialize("", { ...options,
+        expires: new Date(0)
+      });
+    }
+
+  };
+}
+
+/**
+ * Creates and returns a simple in-memory SessionStorage object, mostly useful
+ * for testing and as a reference implementation.
+ *
+ * Note: This storage does not scale beyond a single process, so it is not
+ * suitable for most production scenarios.
+ */
+function createMemorySessionStorage({
+  cookie
+} = {}) {
+  let uniqueId = 0;
+  let map = new Map();
+  return createSessionStorage({
+    cookie,
+
+    async createData(data, expires) {
+      let id = (++uniqueId).toString();
+      map.set(id, {
+        data,
+        expires
+      });
+      return id;
+    },
+
+    async readData(id) {
+      if (map.has(id)) {
+        let {
+          data,
+          expires
+        } = map.get(id);
+
+        if (!expires || expires > new Date()) {
+          return data;
+        } // Remove expired session data.
+
+
+        if (expires) map.delete(id);
+      }
+
+      return null;
+    },
+
+    async updateData(id, data, expires) {
+      map.set(id, {
+        data,
+        expires
+      });
+    },
+
+    async deleteData(id) {
+      map.delete(id);
+    }
+
+  });
+}
+
+export { createCookie, createCookieSessionStorage, createMemorySessionStorage, createRequestHandler, createSession, createSessionStorage, isCookie, isSession, json, redirect };
diff --git a/node_modules/@remix-run/server-runtime/server.js b/node_modules/@remix-run/server-runtime/server.js
index eef3403..988ba5f 100644
--- a/node_modules/@remix-run/server-runtime/server.js
+++ b/node_modules/@remix-run/server-runtime/server.js
@@ -167,7 +167,7 @@ async function handleDataRequest(request, loadContext, build, platform, matches)
     let headers = new Headers(response.headers);
     headers.set("X-Remix-Redirect", headers.get("Location"));
     headers.delete("Location");
-    return new Response("", {
+    return new Response(null, {
       status: 204,
       headers
     });
